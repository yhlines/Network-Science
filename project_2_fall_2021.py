# -*- coding: utf-8 -*-
"""Project-2-Fall-2021.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HhhkUBWPN_QJqrYdXU5h_FogJlw38ukE

# CS 5483 Network Science

## Project 2 Fall 2021

### Due: September 24 at 9 AM
"""

# Commented out IPython magic to ensure Python compatibility.
# Project 2 Yunhao Lin
# %matplotlib inline

import matplotlib.pyplot as plt
import networkx as nx

"""### Quesiton 1:

a) Generate a random undirected graph with 20 nodes with degree densities 0.1, 0.2 and 0.3 - UG1, UG2 and UG3.
"""

UG1 = nx.fast_gnp_random_graph(20, 0.1)
nx.draw(UG1,with_labels=True)

UG2 = nx.fast_gnp_random_graph(20, 0.2)
nx.draw(UG2,with_labels=True)

UG3 = nx.fast_gnp_random_graph(20, 0.3)
nx.draw(UG3,with_labels=True)

"""---


b) Find the number of connected components in each of the three graphs UG1, UG2, and UG3


"""

components1 = nx.connected_components(UG1)
for component in components1:
    print(f'{len(component)}: {component}')

components2 = nx.connected_components(UG2)
for component in components2:
    print(f'{len(component)}: {component}')

components3 = nx.connected_components(UG3)
for component in components3:
    print(f'{len(component)}: {component}')

"""---

c) Show the adjacency matrix of UG1 and edge list of UG1

2
"""

A = nx.adjacency_matrix(UG1)
matA = A.todense()
print(matA)
# Print the edge list
print ('Edge List')
for line in nx.generate_edgelist(UG1, data=False):
    print(line)

A = nx.adjacency_matrix(UG2)
matA = A.todense()
print(matA)
# Print the edge list
print ('Edge List')
for line in nx.generate_edgelist(UG2, data=False):
    print(line)

"""
---
d) Choose two nodes in UG2; Find all paths between those two nodes;"""

print ('All the Paths from vertex 9 to 18')
for path in nx.all_simple_paths(UG2, source=9, target=18):
    print(path)

"""
---

d) Take the graph UG1. Take an edge (x, y); Remove (x, y) from UG1; call the new graph UG11; Find the number of connected components for UG11; Repeat this process for all edges (x, y) in UG1; FIND THE EDGE THAT RESULTS IN THE MAXIMUM NUMBER OF CONNECTED COMPONENTS
"""

num = len(UG1)
maxConCom = nx.number_connected_components(UG1)
listA = []
listB = []
for x in range(0, num-1):
  for y in range(x+1, num):
    if (UG1.has_edge(x, y)):
      UG11 = UG1.copy()
      UG11.remove_edge(x,y)   
      # The follow steps save the maximum number of connected components with their edge(x, y) in listA and listB
      # If there is a same one, save those as well
      # If found a larger one, delete all the previous edge and save the new one   
      if (maxConCom < nx.number_connected_components(UG11)): 
        maxConCom = nx.number_connected_components(UG11)
        listA = []
        listB = [] 
        listA.append(x)
        listB.append(y)      
      elif (maxConCom == nx.number_connected_components(UG11)):                 
        listA.append(x)
        listB.append(y)

sizeofList = len(listA)
print('The maximum number of connected components is %d' % maxConCom)
print('The maximum connected components with removal of these edges:')
for n in range(0, sizeofList):
  print('(%d, %d)' % (listA[n], listB[n]))

nx.draw(UG1,with_labels=True)

"""---


### Question 2:

a) Generate a random **directed** 20 node graph with degree densities 0.1, 0.2 and 0.3 - DG1, DG2 and 
DG3.
"""

DG1 = nx.fast_gnp_random_graph(20,0.1,directed=True)
nx.draw(DG1,with_labels=True)

DG2 = nx.fast_gnp_random_graph(20,0.2,directed=True)
nx.draw(DG2,with_labels=True)

DG3 = nx.fast_gnp_random_graph(20,0.3,directed=True)
nx.draw(DG3,with_labels=True)

"""


---


b) Take the graph DG1. Take an ARC (x, y); Remove (x, y) from DG1; call the new graph DG11; Find the number of **strongly connected** components for DG11; Repeat this process for all edges (x, y) in DG1; FIND THE **ARC** THAT RESULTS IN THE MAXIMUM NUMBER OF **Stronlgy CONNECTED** COMPONENTS"""

numb = len(DG1) 
maxStrCon = 0
listC = [] # Creat a list of the first node of ARCs
listD = [] # Creat a list of the second node of ARCs
for x in range(0, numb):
  for y in range(0, numb):
    if (DG1.has_edge(x, y)):
      DG11 = DG1.copy()
      DG11.remove_edge(x,y)
      strong_components = nx.strongly_connected_components(DG11)
      # The follow steps save the ARC(x, y) with the maximum number in listC and listD
      # If it's same then save the ARC, if it's larger then erase all of the previous ARCs
      # And create a new lists with the new maximum
      m = 0
      for strong_component in strong_components:
        m += 1
      if maxStrCon < m:
        maxStrCon = m
        listC = []
        listD = [] 
        listC.append(x)
        listD.append(y)      
      elif (maxStrCon == m):                 
        listC.append(x)
        listD.append(y)

sizeofList2 = len(listC)
print('The maximum number of strongly connected components is %d' % maxStrCon)
print('The maximum connected components with removal of these ARC:')
for n in range(0, sizeofList2):
  print('(%d, %d)' % (listC[n], listD[n]))

"""---


c) Choose two nodes in DG1; Find all directed paths between those two nodes
"""

print ('All the Paths from vertex 2 to 8')
for path in nx.all_simple_paths(DG2, source=2, target=8): 
    print(path)